import React, { createContext, useContext, useState, useCallback } from "react";

export type Join = {
  type: string;
  table: string;
  baseColumn: string;
  column: string;
};

export type QueryState = {
  table: string;
  columns: { table: string; column: string }[];
  joins: Join[];
  limit: number;
  filters: { table: string; column: string; op: string; value: string }[];
  orderBy: { table: string; column: string; direction: 'ASC' | 'DESC' }[];
};

interface SqlBuilderContextValue {
  queryState: QueryState;
  setQueryState: React.Dispatch<React.SetStateAction<QueryState>>;
  sql: string;
  setSql: React.Dispatch<React.SetStateAction<string>>;
  updateFromVisual: (state: QueryState) => void;
  updateFromSql: (sql: string) => void;
  generateSql: (state: QueryState) => string;
  parseSql: (sql: string) => QueryState;
}

const SqlBuilderContext = createContext<SqlBuilderContextValue | undefined>(undefined);

export function SqlBuilderProvider({ children }: { children: React.ReactNode }) {
  const [queryState, setQueryState] = useState<QueryState>({
    table: "",
    columns: [],
    joins: [],
    limit: 100,
    filters: [],
    orderBy: [],
  });
  const [sql, setSql] = useState<string>("");

  // Generate SQL from state (basic, can be improved)
  const generateSql = useCallback((state: QueryState) => {
    if (!state.table) return "";
    // Assign aliases
    const joinedTables = [
      ...(state.table ? [{ table_name: state.table }] : []),
      ...state.joins.map(j => ({ table_name: j.table })),
    ];
    const tableAliases: Record<string, string> = {};
    joinedTables.forEach((t, i) => {
      tableAliases[t.table_name] = `t${i}`;
    });
    // SELECT clause
    const cols =
      state.columns.length > 0
        ? state.columns
            .map(
              c =>
                `${tableAliases[c.table]}.${c.column} AS ${c.table}_${c.column}`
            )
            .join(", ")
        : "*";
    // FROM and JOINs
    let sql = `SELECT ${cols} FROM ${state.table} ${tableAliases[state.table]} `;
    state.joins.forEach((j) => {
      sql += `LEFT JOIN ${j.table} ${tableAliases[j.table]} ON ${tableAliases[state.table]}.${j.baseColumn} = ${tableAliases[j.table]}.${j.column} `;
    });
    // WHERE clause
    if (state.filters && state.filters.length > 0) {
      sql += 'WHERE ' + state.filters.map(f => {
        const val = f.op.toUpperCase() === 'LIKE' ? `'%${f.value}%'` : `'${f.value}'`;
        return `${tableAliases[f.table]}.${f.column} ${f.op} ${val}`;
      }).join(' AND ') + ' ';
    }
    // ORDER BY clause
    if (state.orderBy && state.orderBy.length > 0) {
      sql += 'ORDER BY ' + state.orderBy.map(o => `${tableAliases[o.table]}.${o.column} ${o.direction}`).join(', ') + ' ';
    }
    if (state.limit) sql += `LIMIT ${state.limit}`;
    return sql.trim();
  }, []);

  // Parse SQL generated by generateSql back into state (mirrors generateSql logic)
  const parseSqlFromGenerated = useCallback((sql: string): QueryState => {
    // This parser expects the SQL to be in the format generated by generateSql
    // SELECT t0.col1 AS table_col1, t1.col2 AS table2_col2 FROM table t0 LEFT JOIN table2 t1 ON t0.id = t1.id WHERE t0.name = 'foo' AND t1.age > '20' ORDER BY t0.name ASC LIMIT 100
    const state: QueryState = {
      table: "",
      columns: [],
      joins: [],
      limit: 100,
      filters: [],
      orderBy: [],
    };
    // Table and aliases
    const fromMatch = sql.match(/FROM\s+(\w+)\s+(t\d+)/i);
    if (fromMatch) {
      state.table = fromMatch[1];
      const tableAlias = fromMatch[2];
      // Joins
      const joinRegex = /LEFT JOIN (\w+) (t\d+) ON (t\d+)\.(\w+) = (t\d+)\.(\w+)/g;
      let joinMatch;
      const joins: Join[] = [];
      while ((joinMatch = joinRegex.exec(sql))) {
        joins.push({
          type: "LEFT",
          table: joinMatch[1],
          baseColumn: joinMatch[4],
          column: joinMatch[6],
        });
      }
      state.joins = joins;
      // Aliases for columns
      const tableAliases: Record<string, string> = {};
      tableAliases[state.table] = tableAlias;
      joins.forEach((j, i) => {
        tableAliases[j.table] = `t${i + 1}`;
      });
      // Columns
      const selectMatch = sql.match(/SELECT\s+([\s\S]+?)\s+FROM/i);
      if (selectMatch) {
        const colsStr = selectMatch[1].trim();
        if (colsStr === "*") {
          state.columns = [];
        } else {
          // Split by comma, handle AS
          const colParts = colsStr.split(/,\s*/);
          state.columns = colParts.map((part) => {
            // t0.col AS table_col
            const m = part.match(/(t\d+)\.(\w+)\s+AS\s+(\w+)_(\w+)/i);
            if (m) {
              // Find table by alias
              const table = Object.keys(tableAliases).find(
                (tbl) => tableAliases[tbl] === m[1]
              ) || state.table;
              return { table, column: m[2] };
            }
            // fallback: t0.col
            const m2 = part.match(/(t\d+)\.(\w+)/);
            if (m2) {
              const table = Object.keys(tableAliases).find(
                (tbl) => tableAliases[tbl] === m2[1]
              ) || state.table;
              return { table, column: m2[2] };
            }
            return { table: state.table, column: part.trim() };
          });
        }
      }
      // Filters (WHERE)
      const whereMatch = sql.match(/WHERE\s+([\s\S]+?)(ORDER BY|LIMIT|$)/i);
      if (whereMatch) {
        const filtersStr = whereMatch[1].trim();
        if (filtersStr) {
          // Split by AND
          const filterParts = filtersStr.split(/\s+AND\s+/i);
          state.filters = filterParts.map((f) => {
            // t0.col op 'val'
            const m = f.match(/(t\d+)\.(\w+)\s+(=|!=|<|>|<=|>=|ILIKE|LIKE)\s+'(.*?)'/i);
            if (m) {
              const table = Object.keys(tableAliases).find(
                (tbl) => tableAliases[tbl] === m[1]
              ) || state.table;
              return {
                table,
                column: m[2],
                op: m[3],
                value: m[4],
              };
            }
            return { table: state.table, column: "", op: "=", value: "" };
          });
        }
      }
      // Order By
      const orderByMatch = sql.match(/ORDER BY\s+([\s\S]+?)(LIMIT|$)/i);
      if (orderByMatch) {
        const orderByStr = orderByMatch[1].trim();
        if (orderByStr) {
          const orderParts = orderByStr.split(/,\s*/);
          state.orderBy = orderParts.map((o) => {
            // t0.col ASC
            const m = o.match(/(t\d+)\.(\w+)\s+(ASC|DESC)/i);
            if (m) {
              const table = Object.keys(tableAliases).find(
                (tbl) => tableAliases[tbl] === m[1]
              ) || state.table;
              return {
                table,
                column: m[2],
                direction: m[3] === "DESC" ? "DESC" : "ASC",
              };
            }
            return { table: state.table, column: o.trim(), direction: "ASC" };
          });
        }
      }
      // Limit
      const limitMatch = sql.match(/LIMIT\s+(\d+)/i);
      if (limitMatch) {
        state.limit = Number(limitMatch[1]);
      }
    }
    return state;
  }, []);

  // Update state from visual builder
  const updateFromVisual = useCallback((state: QueryState) => {
    setQueryState(state);
    setSql(generateSql(state));
  }, [generateSql]);

  // Update state from SQL editor
  const updateFromSql = useCallback((sql: string) => {
    setSql(sql);
    setQueryState(parseSqlFromGenerated(sql));
  }, [parseSqlFromGenerated]);

  return (
    <SqlBuilderContext.Provider value={{
      queryState,
      setQueryState,
      sql,
      setSql,
      updateFromVisual,
      updateFromSql,
      generateSql,
      parseSql: parseSqlFromGenerated,
    }}>
      {children}
    </SqlBuilderContext.Provider>
  );
}

export function useSqlBuilder() {
  const ctx = useContext(SqlBuilderContext);
  if (!ctx) throw new Error("useSqlBuilder must be used within a SqlBuilderProvider");
  return ctx;
} 